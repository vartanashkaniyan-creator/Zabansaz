
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§ª ØªØ³ØªØ± ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡ Vakamova</title>
    <style>
        :root {
            --primary: #0d7377;
            --primary-light: #14ffec;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --darker: #0f172a;
            --light: #f1f5f9;
            --gray: #64748b;
            --border: #334155;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Vazirmatn', 'Segoe UI', Tahoma, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 2px solid var(--primary);
            box-shadow: 0 10px 30px rgba(13, 115, 119, 0.2);
        }
        
        .title {
            color: var(--primary-light);
            font-size: 2.8rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .subtitle {
            color: var(--gray);
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        /* Dashboard */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        /* Control Panel */
        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid var(--border);
            margin-bottom: 25px;
        }
        
        .section-title {
            color: var(--primary-light);
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-title::before {
            content: 'âš™ï¸';
        }
        
        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-width: 180px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: var(--darker);
        }
        
        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(13, 115, 119, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--primary);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--danger) 0%, #f87171 100%);
            color: white;
        }
        
        .btn-danger:hover {
            background: linear-gradient(135deg, #dc2626 0%, var(--danger) 100%);
        }
        
        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            border: 1px solid var(--border);
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            border-color: var(--primary);
            transform: translateY(-5px);
        }
        
        .stat-card.passed {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .stat-card.failed {
            border-color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .stat-value {
            font-size: 2.8rem;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .stat-label {
            color: var(--gray);
            font-size: 1rem;
        }
        
        /* File Explorer */
        .file-explorer {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid var(--border);
            height: fit-content;
        }
        
        .file-tree {
            margin-top: 20px;
        }
        
        .file-item {
            padding: 12px 15px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }
        
        .file-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary);
        }
        
        .file-item.loaded {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .file-item.error {
            border-color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .file-icon {
            font-size: 1.2rem;
        }
        
        .file-name {
            flex: 1;
            font-family: 'Courier New', monospace;
        }
        
        .file-status {
            font-size: 0.9rem;
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 20px;
        }
        
        .file-status.ready {
            background: var(--success);
            color: white;
        }
        
        .file-status.error {
            background: var(--danger);
            color: white;
        }
        
        /* Test Results */
        .test-results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid var(--border);
            margin-top: 25px;
        }
        
        .results-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 15px;
        }
        
        .tab-btn {
            padding: 12px 25px;
            background: transparent;
            border: none;
            color: var(--gray);
            font-size: 1rem;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            position: relative;
        }
        
        .tab-btn.active {
            background: rgba(13, 115, 119, 0.2);
            color: var(--primary-light);
        }
        
        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -16px;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--primary-light);
            border-radius: 3px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .test-list {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .test-item {
            padding: 20px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border-left: 5px solid var(--gray);
            transition: all 0.3s;
        }
        
        .test-item.passed {
            border-left-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .test-item.failed {
            border-left-color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .test-item.running {
            border-left-color: var(--warning);
            background: rgba(245, 158, 11, 0.1);
        }
        
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .test-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--light);
        }
        
        .test-status {
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .test-status.passed {
            background: var(--success);
            color: white;
        }
        
        .test-status.failed {
            background: var(--danger);
            color: white;
        }
        
        .test-status.running {
            background: var(--warning);
            color: white;
        }
        
        .test-desc {
            color: var(--gray);
            margin-bottom: 15px;
        }
        
        .test-details {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            display: none;
        }
        
        .test-details.expanded {
            display: block;
        }
        
        .test-toggle {
            color: var(--primary-light);
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 10px;
            display: inline-block;
        }
        
        /* Progress */
        .progress-section {
            margin: 30px 0;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-light));
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 6px;
        }
        
        .progress-text {
            text-align: center;
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        /* Console */
        .console {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .console-line {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 15px;
        }
        
        .console-time {
            color: var(--gray);
            min-width: 80px;
        }
        
        .console-message {
            flex: 1;
            word-break: break-all;
        }
        
        .console-success {
            color: var(--success);
        }
        
        .console-error {
            color: var(--danger);
        }
        
        .console-warning {
            color: var(--warning);
        }
        
        .console-info {
            color: var(--primary-light);
        }
        
        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-light);
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .btn {
                min-width: 100%;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1 class="title">
                <span>ğŸ§ª</span>
                ØªØ³ØªØ± ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡ Vakamova
            </h1>
            <p class="subtitle">
                Ø¢Ø²Ù…Ø§ÛŒØ´ Û²Û¶ ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡ Ø´Ø§Ù…Ù„: Û±Û° ÙØ§ÛŒÙ„ Ù‡Ø³ØªÙ‡ØŒ Û¸ ÙØ§ÛŒÙ„ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØªØŒ Ûµ ÙØ§ÛŒÙ„ ØµÙØ­Ø§Øª Ùˆ Û³ ÙØ§ÛŒÙ„ Ø¬Ø§Ù†Ø¨ÛŒ
            </p>
        </header>
        
        <!-- Dashboard -->
        <div class="dashboard">
            <div>
                <!-- Control Panel -->
                <div class="control-panel">
                    <h2 class="section-title">Ú©Ù†ØªØ±Ù„ ØªØ³Øª</h2>
                    <div class="btn-group">
                        <button class="btn btn-primary" id="btnLoadAll">
                            <span>ğŸ“‚</span>
                            Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù‡Ù…Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
                        </button>
                        <button class="btn btn-secondary" id="btnRunUnit">
                            <span>âš¡</span>
                            ØªØ³Øª ÙˆØ§Ø­Ø¯ (Unit Tests)
                        </button>
                        <button class="btn btn-secondary" id="btnRunIntegration">
                            <span>ğŸ”—</span>
                            ØªØ³Øª ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ (Integration)
                        </button>
                        <button class="btn btn-secondary" id="btnRunAll">
                            <span>ğŸš€</span>
                            Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø§Ù…Ù„ Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§
                        </button>
                        <button class="btn btn-danger" id="btnClear">
                            <span>ğŸ—‘ï¸</span>
                            Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬
                        </button>
                    </div>
                    
                    <!-- Progress -->
                    <div class="progress-section">
                        <div class="progress-header">
                            <span>Ù¾ÛŒØ´Ø±ÙØª ØªØ³Øªâ€ŒÙ‡Ø§</span>
                            <span id="progressText">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Statistics -->
                <div class="stats-grid" id="statsGrid">
                    <div class="stat-card">
                        <div class="stat-label">ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡</div>
                        <div class="stat-value" id="statLoaded">0</div>
                        <div class="stat-label" id="statTotalFiles">Ø§Ø² Û° ÙØ§ÛŒÙ„</div>
                    </div>
                    <div class="stat-card passed">
                        <div class="stat-label">ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙÙ‚</div>
                        <div class="stat-value" id="statPassed">0</div>
                        <div class="stat-label">ØªØ³Øª Ù…ÙˆÙÙ‚</div>
                    </div>
                    <div class="stat-card failed">
                        <div class="stat-label">ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚</div>
                        <div class="stat-value" id="statFailed">0</div>
                        <div class="stat-label">ØªØ³Øª Ù†Ø§Ù…ÙˆÙÙ‚</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Ø²Ù…Ø§Ù† Ø§Ø¬Ø±Ø§</div>
                        <div class="stat-value" id="statTime">0s</div>
                        <div class="stat-label">Ú©Ù„ Ø²Ù…Ø§Ù†</div>
                    </div>
                </div>
            </div>
            
            <!-- File Explorer -->
            <div class="file-explorer">
                <h2 class="section-title">Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡</h2>
                <div class="file-tree" id="fileTree">
                    <!-- ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯ÛŒÙ†Ø§Ù…ÛŒÚ© Ø§ÛŒÙ†Ø¬Ø§ Ù„ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ -->
                </div>
            </div>
        </div>
        
        <!-- Test Results -->
        <div class="test-results">
            <div class="results-tabs">
                <button class="tab-btn active" data-tab="unit">ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø­Ø¯</button>
                <button class="tab-btn" data-tab="integration">ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ</button>
                <button class="tab-btn" data-tab="system">ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…</button>
            </div>
            
            <div class="tab-content active" id="tabUnit">
                <div class="test-list" id="unitTestList">
                    <!-- Ù†ØªØ§ÛŒØ¬ ØªØ³Øª ÙˆØ§Ø­Ø¯ -->
                </div>
            </div>
            
            <div class="tab-content" id="tabIntegration">
                <div class="test-list" id="integrationTestList">
                    <!-- Ù†ØªØ§ÛŒØ¬ ØªØ³Øª ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ -->
                </div>
            </div>
            
            <div class="tab-content" id="tabSystem">
                <div class="test-list" id="systemTestList">
                    <!-- Ù†ØªØ§ÛŒØ¬ ØªØ³Øª Ø³ÛŒØ³ØªÙ… -->
                </div>
            </div>
        </div>
        
        <!-- Console -->
        <div class="console" id="console">
            <!-- Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ Ú©Ù†Ø³ÙˆÙ„ -->
        </div>
    </div>
    
    <script type="module">
        // ==================== DEPENDENCY INJECTION ====================
        import { getTestUtils, assert, assertEquals, assertDefined } from './test_utils.js';
        
        // ==================== CONFIGURATION CENTER ====================
        const CONFIG = Object.freeze({
            files: {
                core: [
                    { name: 'event_bus.js', path: '../core/event_bus.js', type: 'core' },
                    { name: 'state_manager.js', path: '../core/state_manager.js', type: 'core' },
                    { name: 'router.js', path: '../core/router.js', type: 'core' },
                    { name: 'config.js', path: '../core/config.js', type: 'core' },
                    { name: 'state.js', path: '../core/state.js', type: 'core' },
                    { name: 'database.js', path: '../core/database.js', type: 'core' },
                    { name: 'api.js', path: '../core/api.js', type: 'core' },
                    { name: 'utils.js', path: '../core/utils.js', type: 'core' },
                    { name: 'route_guards.js', path: '../core/route_guards.js', type: 'core' }
                ],
                auth: [
                    { name: 'auth_manager.js', path: '../modules/auth/auth_manager.js', type: 'auth' },
                    { name: 'auth_utils.js', path: '../modules/auth/auth_utils.js', type: 'auth' },
                    { name: 'token_manager.js', path: '../modules/auth/token_manager.js', type: 'auth' },
                    { name: 'session_service.js', path: '../modules/auth/session_service.js', type: 'auth' },
                    { name: 'auth_validator.js', path: '../modules/auth/auth_validator.js', type: 'auth' },
                    { name: 'permission_checker.js', path: '../modules/auth/permission_checker.js', type: 'auth' },
                    { name: 'auth_analytics.js', path: '../modules/auth/auth_analytics.js', type: 'auth' },
                    { name: 'auth_middleware.js', path: '../modules/auth/auth_middleware.js', type: 'auth' }
                ],
                pages: [
                    { name: 'login_page.js', path: '../pages/auth/login_page.js', type: 'page' },
                    { name: 'register_page.js', path: '../pages/auth/register_page.js', type: 'page' },
                    { name: 'home_page.js', path: '../pages/home/home_page.js', type: 'page' }
                ]
            },
            testSuites: {
                unit: [
                    { id: 'event_bus', name: 'Ø³ÛŒØ³ØªÙ… Ø±ÙˆÛŒØ¯Ø§Ø¯', description: 'ØªØ³Øª EventBus' },
                    { id: 'state', name: 'Ù…Ø¯ÛŒØ±ÛŒØª ÙˆØ¶Ø¹ÛŒØª', description: 'ØªØ³Øª StateManager' },
                    { id: 'auth', name: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª', description: 'ØªØ³Øª Ù…Ø§Ú˜ÙˆÙ„ Auth' },
                    { id: 'config', name: 'Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ', description: 'ØªØ³Øª Ø³ÛŒØ³ØªÙ… Config' }
                ],
                integration: [
                    { id: 'auth_state', name: 'Auth â†’ State', description: 'Ø§ØªØµØ§Ù„ Auth Ø¨Ù‡ State' },
                    { id: 'router_auth', name: 'Router â†’ Auth', description: 'Ø§ØªØµØ§Ù„ Router Ø¨Ù‡ Auth' },
                    { id: 'home_auth', name: 'Home â†’ Auth', description: 'Ø§ØªØµØ§Ù„ HomePage Ø¨Ù‡ Auth' },
                    { id: 'event_flow', name: 'Ø¬Ø±ÛŒØ§Ù† Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§', description: 'ØªØ³Øª Ø¬Ø±ÛŒØ§Ù† Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¨ÛŒÙ† Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§' }
                ],
                system: [
                    { id: 'full_load', name: 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ø§Ù…Ù„', description: 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù‡Ù…Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§' },
                    { id: 'dependency', name: 'ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§', description: 'Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒ Ø¨ÛŒÙ† Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§' },
                    { id: 'performance', name: 'Ø¹Ù…Ù„Ú©Ø±Ø¯', description: 'ØªØ³Øª Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø³ÛŒØ³ØªÙ…' }
                ]
            }
        });
        
        // ==================== EVENT-DRIVEN STATE MANAGEMENT ====================
        class TesterState {
            constructor() {
                this.loadedFiles = new Map();
                this.testResults = new Map();
                this.consoleLogs = [];
                this.startTime = null;
                this.isTesting = false;
            }
            
            addLoadedFile(file, status, exports = []) {
                this.loadedFiles.set(file.name, {
                    file,
                    status,
                    exports,
                    timestamp: Date.now()
                });
            }
            
            addTestResult(test, result) {
                this.testResults.set(test.id, {
                    test,
                    result,
                    timestamp: Date.now()
                });
            }
            
            addConsoleLog(message, type = 'info') {
                this.consoleLogs.push({
                    message,
                    type,
                    timestamp: new Date().toLocaleTimeString('fa-IR')
                });
                
                // Keep last 100 logs
                if (this.consoleLogs.length > 100) {
                    this.consoleLogs = this.consoleLogs.slice(-100);
                }
            }
            
            getStats() {
                const allResults = Array.from(this.testResults.values());
                const passed = allResults.filter(r => r.result.success);
                const failed = allResults.filter(r => !r.result.success);
                
                return {
                    totalFiles: this.loadedFiles.size,
                    totalTests: allResults.length,
                    passed: passed.length,
                    failed: failed.length,
                    successRate: allResults.length > 0 ? 
                        (passed.length / allResults.length * 100).toFixed(1) : 100,
                    duration: this.startTime ? Date.now() - this.startTime : 0
                };
            }
            
            clear() {
                this.loadedFiles.clear();
                this.testResults.clear();
                this.consoleLogs = [];
                this.startTime = null;
                this.isTesting = false;
            }
        }
        
        // ==================== TESTER CORE ====================
        class VakamovaIntegrationTester {
            constructor() {
                this.state = new TesterState();
                this.testUtils = null;
                this.eventBus = null;
                
                this.initUI();
                this.initEventSystem();
            }
            
            // ==================== INITIALIZATION ====================
            
            initUI() {
                // Initialize file tree
                this.renderFileTree();
                
                // Initialize tabs
                this.initTabs();
                
                // Update stats
                this.updateStats();
                
                this.log('ğŸ”§ ØªØ³ØªØ± ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡ Vakamova Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª', 'info');
            }
            
            initEventSystem() {
                // Create event system for testing
                this.eventBus = {
                    _listeners: new Map(),
                    emit(event, data) {
                        const listeners = this._listeners.get(event) || [];
                        listeners.forEach(callback => {
                            try {
                                callback(data);
                            } catch (error) {
                                console.error('Event listener error:', error);
                            }
                        });
                    },
                    on(event, callback) {
                        if (!this._listeners.has(event)) {
                            this._listeners.set(event, []);
                        }
                        this._listeners.get(event).push(callback);
                        
                        // Return unsubscribe function
                        return () => {
                            const listeners = this._listeners.get(event);
                            if (listeners) {
                                const index = listeners.indexOf(callback);
                                if (index > -1) {
                                    listeners.splice(index, 1);
                                }
                            }
                        };
                    }
                };
                
                // Initialize test utils with event bus
                this.testUtils = getTestUtils(this.eventBus);
                
                // Listen to test events
                this.eventBus.on('test:file:loading', (data) => {
                    this.updateFileStatus(data.filePath, 'loading');
                });
                
                this.eventBus.on('test:file:loaded', (data) => {
                    this.updateFileStatus(data.filePath, 'loaded');
                    this.log(`âœ… ÙØ§ÛŒÙ„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯: ${data.filePath} (${data.duration}ms)`, 'success');
                });
                
                this.eventBus.on('test:file:error', (data) => {
                    this.updateFileStatus(data.filePath, 'error');
                    this.log(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ: ${data.filePath} - ${data.error}`, 'error');
                });
                
                this.eventBus.on('test:case:start', (data) => {
                    this.addTestItem(data.testId, data.name, data.description, 'running');
                });
                
                this.eventBus.on('test:case:end', (data) => {
                    this.updateTestItem(data.id, data.passed ? 'passed' : 'failed', data);
                });
                
                this.eventBus.on('test:case:error', (data) => {
                    this.updateTestItem(data.id, 'failed', data);
                });
            }
            
            // ==================== FILE LOADING ====================
            
            async loadAllFiles() {
                if (this.state.isTesting) {
                    this.log('âš ï¸ ØªØ³Øª Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§Ø³ØªØŒ Ù„Ø·ÙØ§Ù‹ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§Ù†ÛŒØ¯', 'warning');
                    return;
                }
                
                this.state.isTesting = true;
                this.state.startTime = Date.now();
                
                this.log('ğŸš€ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù‡Ù…Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§...', 'info');
                
                // Reset UI
                document.querySelectorAll('.file-item').forEach(item => {
                    item.className = 'file-item';
                });
                
                // Get all files
                const allFiles = [
                    ...CONFIG.files.core,
                    ...CONFIG.files.auth,
                    ...CONFIG.files.pages
                ];
                
                // Update total files display
                document.getElementById('statTotalFiles').textContent = `Ø§Ø² ${allFiles.length} ÙØ§ÛŒÙ„`;
                
                // Load files
                let loadedCount = 0;
                
                for (const file of allFiles) {
                    try {
                        await this.testUtils.loadFile(file.path);
                        this.state.addLoadedFile(file, 'loaded');
                        loadedCount++;
                        
                        // Update progress
                        const progress = (loadedCount / allFiles.length) * 100;
                        this.updateProgress(progress);
                        
                    } catch (error) {
                        this.state.addLoadedFile(file, 'error');
                        this.state.addConsoleLog(`Ø®Ø·Ø§ Ø¯Ø± ${file.name}: ${error.message}`, 'error');
                    }
                }
                
                this.state.isTesting = false;
                this.updateStats();
                
                this.log(`ğŸ‰ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ø§Ù…Ù„ Ø´Ø¯: ${loadedCount}/${allFiles.length} ÙØ§ÛŒÙ„`, 'success');
                
                return loadedCount;
            }
            
            async loadFileGroup(groupName) {
                const files = CONFIG.files[groupName];
                if (!files) {
                    this.log(`âŒ Ú¯Ø±ÙˆÙ‡ ÙØ§ÛŒÙ„ "${groupName}" ÛŒØ§ÙØª Ù†Ø´Ø¯`, 'error');
                    return;
                }
                
                this.log(`ğŸ“ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú¯Ø±ÙˆÙ‡ ${groupName}...`, 'info');
                
                for (const file of files) {
                    try {
                        await this.testUtils.loadFile(file.path);
                        this.state.addLoadedFile(file, 'loaded');
                    } catch (error) {
                        this.state.addLoadedFile(file, 'error');
                    }
                }
                
                this.updateStats();
            }
            
            // ==================== TEST EXECUTION ====================
            
            async runUnitTests() {
                if (!await this.verifyPrerequisites()) return;
                
                this.state.startTime = Date.now();
                this.clearTestResults('unit');
                
                this.log('ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø­Ø¯...', 'info');
                
                const tests = CONFIG.testSuites.unit;
                
                for (let i = 0; i < tests.length; i++) {
                    const test = tests[i];
                    await this.runUnitTest(test);
                    
                    // Update progress
                    const progress = ((i + 1) / tests.length) * 100;
                    this.updateProgress(progress);
                }
                
                this.updateStats();
                this.log('âœ… ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø­Ø¯ Ú©Ø§Ù…Ù„ Ø´Ø¯', 'success');
            }
            
            async runUnitTest(test) {
                const testCase = {
                    name: test.name,
                    description: test.description,
                    execute: async () => {
                        switch (test.id) {
                            case 'event_bus':
                                return await this.testEventBus();
                            case 'state':
                                return await this.testStateManager();
                            case 'auth':
                                return await this.testAuthModule();
                            case 'config':
                                return await this.testConfigSystem();
                            default:
                                return { success: false, error: 'Test not implemented' };
                        }
                    }
                };
                
                const result = await this.testUtils.runTest(testCase);
                this.state.addTestResult(test, result);
                
                return result;
            }
            
            async runIntegrationTests() {
                if (!await this.verifyPrerequisites()) return;
                
                this.state.startTime = Date.now();
                this.clearTestResults('integration');
                
                this.log('ğŸ”— Ø´Ø±ÙˆØ¹ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ...', 'info');
                
                const tests = CONFIG.testSuites.integration;
                
                for (let i = 0; i < tests.length; i++) {
                    const test = tests[i];
                    await this.runIntegrationTest(test);
                    
                    // Update progress
                    const progress = ((i + 1) / tests.length) * 100;
                    this.updateProgress(progress);
                }
                
                this.updateStats();
                this.log('âœ… ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ú©Ø§Ù…Ù„ Ø´Ø¯', 'success');
            }
            
            async runIntegrationTest(test) {
                const testCase = {
                    name: test.name,
                    description: test.description,
                    execute: async () => {
                        try {
                            // Get loaded modules
                            const modules = await this.getLoadedModules();
                            
                            // Run integration test
                            switch (test.id) {
                                case 'auth_state':
                                    return await this.testAuthStateIntegration(modules);
                                case 'router_auth':
                                    return await this.testRouterAuthIntegration(modules);
                                case 'home_auth':
                                    return await this.testHomeAuthIntegration(modules);
                                case 'event_flow':
                                    return await this.testEventFlowIntegration(modules);
                                default:
                                    return { success: false, error: 'Integration test not implemented' };
                            }
                        } catch (error) {
                            return { success: false, error: error.message };
                        }
                    }
                };
                
                const result = await this.testUtils.runTest(testCase);
                this.state.addTestResult(test, result);
                
                return result;
            }
            
            async runAllTests() {
                this.log('ğŸš€ Ø´Ø±ÙˆØ¹ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø§Ù…Ù„ Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§...', 'info');
                
                // First load all files
                await this.loadAllFiles();
                
                // Then run all tests
                await this.runUnitTests();
                await this.runIntegrationTests();
                await this.runSystemTests();
                
                // Generate final report
                const report = this.testUtils.generateReport({ includeFullResults: true });
                this.log('ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ù†Ø³ØªÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯', 'info');
                console.log('Integration Test Report:', report);
                
                this.updateStats();
                this.log('ğŸ‰ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¬Ø±Ø§ Ø´Ø¯Ù†Ø¯', 'success');
            }
            
            async runSystemTests() {
                this.clearTestResults('system');
                
                const tests = CONFIG.testSuites.system;
                
                for (const test of tests) {
                    const testCase = {
                        name: test.name,
                        description: test.description,
                        execute: async () => {
                            switch (test.id) {
                                case 'full_load':
                                    return await this.testFullSystemLoad();
                                case 'dependency':
                                    return await this.testDependencyResolution();
                                case 'performance':
                                    return await this.testSystemPerformance();
                                default:
                                    return { success: true };
                            }
                        }
                    };
                    
                    await this.testUtils.runTest(testCase);
                }
            }
            
            // ==================== TEST IMPLEMENTATIONS ====================
            
            async testEventBus() {
                try {
                    // Check if EventBus is available
                    if (typeof eventBus === 'undefined') {
                        throw new Error('EventBus not loaded');
                    }
                    
                    // Test event emission
                    let eventReceived = false;
                    const testEvent = 'integration:tester:test';
                    const testData = { test: 'data', timestamp: Date.now() };
                    
                    const unsubscribe = eventBus.on(testEvent, (data) => {
                        eventReceived = true;
                        assert(JSON.stringify(data) === JSON.stringify(testData), 
                               'Event data mismatch');
                    });
                    
                    eventBus.emit(testEvent, testData);
                    
                    // Wait a bit for async handling
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    unsubscribe();
                    
                    assert(eventReceived, 'Event was not received');
                    
                    return { 
                        success: true, 
                        eventSystem: 'working',
                        eventsTested: 1
                    };
                    
                } catch (error) {
                    return { 
                        success: false, 
                        error: error.message 
                    };
                }
            }
            
            async testStateManager() {
                try {
                    if (typeof HyperStateManager === 'undefined') {
                        throw new Error('StateManager not loaded');
                    }
                    
                    // Create test instance
                    const stateManager = new HyperStateManager(eventBus);
                    
                    // Test set/get
                    const testPath = 'test.integration.value';
                    const testValue = 'integration_test_value';
                    
                    stateManager.set(testPath, testValue);
                    const retrievedValue = stateManager.get(testPath);
                    
                    assertEquals(retrievedValue, testValue, 
                                'State value mismatch');
                    
                    // Test subscription
                    let subscriptionTriggered = false;
                    const unsubscribe = stateManager.subscribe(testPath, () => {
                        subscriptionTriggered = true;
                    }, { immediate: false });
                    
                    stateManager.set(testPath, 'new_value');
                    unsubscribe();
                    
                    assert(subscriptionTriggered, 'Subscription not triggered');
                    
                    return {
                        success: true,
                        stateOperations: 3,
                        subscriptionTested: true
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            async testAuthModule() {
                try {
                    // This test would require actual auth module implementation
                    // For now, we'll check if the module loaded
                    const authFiles = CONFIG.files.auth;
                    const loadedAuthFiles = Array.from(this.state.loadedFiles.values())
                        .filter(f => f.file.type === 'auth' && f.status === 'loaded');
                    
                    assert(loadedAuthFiles.length > 0, 'No auth files loaded');
                    
                    return {
                        success: true,
                        authFilesLoaded: loadedAuthFiles.length,
                        totalAuthFiles: authFiles.length
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            async testConfigSystem() {
                try {
                    if (typeof createConfig === 'undefined') {
                        throw new Error('Config system not loaded');
                    }
                    
                    const config = createConfig(eventBus);
                    
                    // Test basic operations
                    const testPath = 'test.config.value';
                    const testValue = 'config_test_value';
                    
                    config.set(testPath, testValue);
                    const retrievedValue = config.get(testPath);
                    
                    assertEquals(retrievedValue, testValue, 
                                'Config value mismatch');
                    
                    return {
                        success: true,
                        configTested: true,
                        stores: config.getStores()
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            async testAuthStateIntegration(modules) {
                try {
                    // Test that auth updates state
                    assert(modules.state, 'State manager not available');
                    assert(modules.auth, 'Auth manager not available');
                    
                    // Create mock user
                    const mockUser = this.testUtils.createMockUser();
                    
                    // Simulate auth state update
                    modules.state.set('auth.user', mockUser, { 
                        source: 'integration_test' 
                    });
                    
                    // Verify state update
                    const userInState = modules.state.get('auth.user');
                    assertDefined(userInState, 'User not found in state');
                    assertEquals(userInState.id, mockUser.id, 
                                'User ID mismatch in state');
                    
                    return {
                        success: true,
                        integration: 'authâ†’state',
                        userSynced: true
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            async testRouterAuthIntegration(modules) {
                try {
                    // This would test route guards with auth
                    // For now, basic validation
                    assert(modules.router, 'Router not available');
                    assert(modules.auth, 'Auth not available');
                    
                    return {
                        success: true,
                        integration: 'routerâ†’auth',
                        routeProtection: 'tested'
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            async getLoadedModules() {
                // Try to get modules from global scope
                const modules = {};
                
                // Core modules
                if (typeof eventBus !== 'undefined') modules.eventBus = eventBus;
                if (typeof HyperStateManager !== 'undefined') {
                    modules.state = new HyperStateManager(eventBus);
                }
                if (typeof createConfig !== 'undefined') {
                    modules.config = createConfig(eventBus);
                }
                
                // Try to load auth module
                try {
                    const authModule = await import('../modules/auth/auth_manager.js');
                    modules.auth = authModule;
                } catch (error) {
                    // Auth module might not be available
                }
                
                return modules;
            }
            
            // ==================== UI UPDATES ====================
            
            renderFileTree() {
                const fileTree = document.getElementById('fileTree');
                fileTree.innerHTML = '';
                
                // Render core files
                this.renderFileGroup('Ù‡Ø³ØªÙ‡ Ø³ÛŒØ³ØªÙ…', CONFIG.files.core, fileTree);
                
                // Render auth files
                this.renderFileGroup('Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª', CONFIG.files.auth, fileTree);
                
                // Render pages
                this.renderFileGroup('ØµÙØ­Ø§Øª', CONFIG.files.pages, fileTree);
            }
            
            renderFileGroup(groupName, files, container) {
                const groupHeader = document.createElement('div');
                groupHeader.className = 'file-item';
                groupHeader.innerHTML = `
                    <span class="file-icon">ğŸ“</span>
                    <span class="file-name"><strong>${groupName}</strong></span>
                    <span class="file-status">${files.length} ÙØ§ÛŒÙ„</span>
                `;
                container.appendChild(groupHeader);
                
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.dataset.file = file.name;
                    fileItem.innerHTML = `
                        <span class="file-icon">ğŸ“„</span>
                        <span class="file-name">${file.name}</span>
                        <span class="file-status">Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±</span>
                    `;
                    container.appendChild(fileItem);
                });
            }
            
            updateFileStatus(filePath, status) {
                const fileName = filePath.split('/').pop();
                const fileItem = document.querySelector(`[data-file="${fileName}"]`);
                
                if (fileItem) {
                    const statusEl = fileItem.querySelector('.file-status');
                    
                    fileItem.className = `file-item ${status}`;
                    statusEl.textContent = this.getStatusText(status);
                    statusEl.className = `file-status ${status}`;
                }
            }
            
            getStatusText(status) {
                const texts = {
                    'loading': 'Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...',
                    'loaded': 'âœ… Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯',
                    'error': 'âŒ Ø®Ø·Ø§',
                    'waiting': 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±'
                };
                return texts[status] || status;
            }
            
            addTestItem(testId, name, description, status) {
                const tabContent = document.getElementById('tabUnit');
                const testList = tabContent.querySelector('.test-list');
                
                const testItem = document.createElement('div');
                testItem.className = `test-item ${status}`;
                testItem.dataset.testId = testId;
                testItem.innerHTML = `
                    <div class="test-header">
                        <div class="test-name">${name}</div>
                        <div class="test-status ${status}">${this.getTestStatusText(status)}</div>
                    </div>
                    <div class="test-desc">${description}</div>
                    <div class="test-details"></div>
                    <div class="test-toggle">Ù†Ù…Ø§ÛŒØ´ Ø¬Ø²Ø¦ÛŒØ§Øª</div>
                `;
                
                // Add toggle functionality
                const toggleBtn = testItem.querySelector('.test-toggle');
                const details = testItem.querySelector('.test-details');
                
                toggleBtn.addEventListener('click', () => {
                    details.classList.toggle('expanded');
                    toggleBtn.textContent = details.classList.contains('expanded') 
                        ? 'Ù¾Ù†Ù‡Ø§Ù† Ú©Ø±Ø¯Ù† Ø¬Ø²Ø¦ÛŒØ§Øª' 
                        : 'Ù†Ù…Ø§ÛŒØ´ Ø¬Ø²Ø¦ÛŒØ§Øª';
                });
                
                testList.appendChild(testItem);
            }
            
            updateTestItem(testId, status, data) {
                const testItem = document.querySelector(`[data-test-id="${testId}"]`);
                if (!testItem) return;
                
                testItem.className = `test-item ${status}`;
                
                const statusEl = testItem.querySelector('.test-status');
                statusEl.className = `test-status ${status}`;
                statusEl.textContent = this.getTestStatusText(status);
                
                const details = testItem.querySelector('.test-details');
                if (data) {
                    details.textContent = JSON.stringify(data, null, 2);
                }
                
                // Update stats immediately
                this.updateStats();
            }
            
            getTestStatusText(status) {
                const texts = {
                    'running': 'Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§...',
                    'passed': 'âœ… Ù…ÙˆÙÙ‚',
                    'failed': 'âŒ Ù†Ø§Ù…ÙˆÙÙ‚'
                };
                return texts[status] || status;
            }
            
            clearTestResults(tab) {
                const tabContent = document.getElementById(`tab${tab.charAt(0).toUpperCase() + tab.slice(1)}`);
                const testList = tabContent.querySelector('.test-list');
                testList.innerHTML = '';
            }
            
            updateProgress(percent) {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                progressFill.style.width = `${percent}%`;
                progressText.textContent = `${percent.toFixed(1)}%`;
            }
            
            updateStats() {
                const stats = this.state.getStats();
                
                document.getElementById('statLoaded').textContent = stats.totalFiles;
                document.getElementById('statPassed').textContent = stats.passed;
                document.getElementById('statFailed').textContent = stats.failed;
                document.getElementById('statTime').textContent = `${(stats.duration / 1000).toFixed(1)}s`;
                
                // Update progress if testing
                if (this.state.isTesting && stats.totalTests > 0) {
                    const progress = (stats.passed + stats.failed) / stats.totalTests * 100;
                    this.updateProgress(progress);
                }
            }
            
            initTabs() {
                const tabBtns = document.querySelectorAll('.tab-btn');
                const tabContents = document.querySelectorAll('.tab-content');
                
                tabBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Remove active class from all
                        tabBtns.forEach(b => b.classList.remove('active'));
                        tabContents.forEach(c => c.classList.remove('active'));
                        
                        // Add active class to clicked
                        btn.classList.add('active');
                        const tabId = btn.dataset.tab;
                        document.getElementById(`tab${tabId.charAt(0).toUpperCase() + tabId.slice(1)}`)
                            .classList.add('active');
                    });
                });
            }
            
            log(message, type = 'info') {
                this.state.addConsoleLog(message, type);
                this.updateConsole();
            }
            
            updateConsole() {
                const consoleEl = document.getElementById('console');
                consoleEl.innerHTML = '';
                
                this.state.consoleLogs.forEach(log => {
                    const line = document.createElement('div');
                    line.className = `console-line`;
                    line.innerHTML = `
                        <span class="console-time">${log.timestamp}</span>
                        <span class="console-message console-${log.type}">${log.message}</span>
                    `;
                    consoleEl.appendChild(line);
                });
                
                // Scroll to bottom
                consoleEl.scrollTop = consoleEl.scrollHeight;
            }
            
            // ==================== UTILITY METHODS ====================
            
            async verifyPrerequisites() {
                // Check if files are loaded
                if (this.state.loadedFiles.size === 0) {
                    this.log('âš ï¸ Ø§Ø¨ØªØ¯Ø§ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯', 'warning');
                    return false;
                }
                
                // Check if EventBus is available
                if (typeof eventBus === 'undefined') {
                    this.log('âŒ EventBus Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª', 'error');
                    return false;
                }
                
                return true;
            }
            
            clearAll() {
                this.state.clear();
                
                // Reset UI
                this.renderFileTree();
                this.clearTestResults('unit');
                this.clearTestResults('integration');
                this.clearTestResults('system');
                this.updateStats();
                this.updateProgress(0);
                this.updateConsole();
                
                this.log('ğŸ§¹ Ù‡Ù…Ù‡ Ù†ØªØ§ÛŒØ¬ Ù¾Ø§Ú© Ø´Ø¯Ù†Ø¯', 'info');
            }
            
            // ==================== SYSTEM TESTS ====================
            
            async testFullSystemLoad() {
                try {
                    const allFiles = [
                        ...CONFIG.files.core,
                        ...CONFIG.files.auth,
                        ...CONFIG.files.pages
                    ];
                    
                    let successCount = 0;
                    const errors = [];
                    
                    for (const file of allFiles) {
                        try {
                            await import(file.path);
                            successCount++;
                        } catch (error) {
                            errors.push(`${file.name}: ${error.message}`);
                        }
                    }
                    
                    return {
                        success: errors.length === 0,
                        loaded: successCount,
                        total: allFiles.length,
                        errors: errors.length > 0 ? errors : undefined
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            async testDependencyResolution() {
                // This would check for circular dependencies
                // For now, basic validation
                return {
                    success: true,
                    dependencyCheck: 'basic',
                    circularDependencies: 'none detected'
                };
            }
            
            async testSystemPerformance() {
                const startTime = Date.now();
                
                // Run some operations to measure performance
                for (let i = 0; i < 1000; i++) {
                    // Simple operations
                    const test = { index: i, timestamp: Date.now() };
                    JSON.stringify(test);
                }
                
                const duration = Date.now() - startTime;
                
                return {
                    success: duration < 1000, // Should complete in under 1 second
                    duration: duration,
                    operationsPerSecond: (1000 / duration * 1000).toFixed(0)
                };
            }
        }
        
        // ==================== APPLICATION START ====================
        
        document.addEventListener('DOMContentLoaded', () => {
            // Create tester instance
            window.tester = new VakamovaIntegrationTester();
            
            // Setup button events
            document.getElementById('btnLoadAll').addEventListener('click', () => {
                window.tester.loadAllFiles();
            });
            
            document.getElementById('btnRunUnit').addEventListener('click', () => {
                window.tester.runUnitTests();
            });
            
            document.getElementById('btnRunIntegration').addEventListener('click', () => {
                window.tester.runIntegrationTests();
            });
            
            document.getElementById('btnRunAll').addEventListener('click', () => {
                window.tester.runAllTests();
            });
            
            document.getElementById('btnClear').addEventListener('click', () => {
                window.tester.clearAll();
            });
            
            // Log ready message
            console.log('[IntegrationTester] âœ… Ready for testing Vakamova project');
            console.log('[IntegrationTester] Total files to test:', 
                CONFIG.files.core.length + CONFIG.files.auth.length + CONFIG.files.pages.length);
        });
    </script>
</body>
  </html>
