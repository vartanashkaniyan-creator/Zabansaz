/**
 * VAKAMOVA CONFIG MANAGER - سیستم مدیریت پیکربندی متمرکز
 * اصول: تزریق وابستگی، قرارداد رابط، رویدادمحور، پیکربندی متمرکز
 * وابستگی: فقط event_bus.js (برای ارتباط رویدادمحور)
 */

class VakamovaConfig {
    constructor(eventSystem, options = {}) {
        // ==================== پیکربندی متمرکز ====================
        this._config = Object.freeze({
            sources: {
                environment: options.envPrefix || 'VAKAMOVA_',
                files: options.configFiles || ['config.json', 'settings.json'],
                remote: options.remoteUrl || null,
                defaults: options.defaults || {}
            },
            validation: {
                strict: options.strictValidation ?? true,
                schemas: options.schemas || {}
            },
            caching: {
                enabled: options.cacheEnabled ?? true,
                ttl: options.cacheTTL || 300000,
                strategy: options.cacheStrategy || 'memory'
            },
            security: {
                encryptSensitive: options.encryptSensitive ?? true,
                encryptionKey: options.encryptionKey || null,
                maskKeys: options.maskKeys || ['password', 'token', 'secret']
            },
            ...options
        });

        // ==================== تزریق وابستگی ====================
        this._eventBus = eventSystem || window.eventBus || {
            emit: (e, d) => console.log(`[Config] ${e}:`, d),
            on: () => () => {}
        };

        // ==================== وضعیت داخلی ====================
        this._state = {
            initialized: false,
            loading: false,
            lastLoad: null,
            validationErrors: [],
            watchers: new Map()
        };

        this._data = new Map();
        this._encryptedData = new Map();
        this._sourceCache = new Map();
        this._adapters = new Map();
        this._validationCache = new Map();

        this._initializeAdapters();
        Object.seal(this._state);
    }

    // ==================== قرارداد رابط - API عمومی ====================
    async init() {
        if (this._state.initialized) {
            this._eventBus.emit('config:init:skipped', { reason: 'already_initialized' });
            return this;
        }

        this._state.loading = true;
        this._eventBus.emit('config:init:start');

        try {
            await this._loadAllSources();
            await this._validateAll();
            await this._mergeConfigurations();
            
            this._state.initialized = true;
            this._state.lastLoad = Date.now();
            
            this._eventBus.emit('config:init:success', {
                sources: Array.from(this._data.keys()),
                count: this._data.size,
                timestamp: this._state.lastLoad
            });

        } catch (error) {
            this._state.loading = false;
            this._eventBus.emit('config:init:error', {
                error: error.message,
                stack: error.stack
            });
            throw error;
        }

        this._state.loading = false;
        return this;
    }

    get(key, defaultValue = null) {
        this._ensureInitialized();
        
        if (key === '*') {
            return this._getAllDecrypted();
        }

        const path = this._normalizePath(key);
        const value = this._getValueByPath(path);
        
        if (value === undefined) {
            this._eventBus.emit('config:get:miss', { key, defaultValue });
            return defaultValue;
        }

        const decrypted = this._decryptIfNeeded(key, value);
        this._eventBus.emit('config:get:success', { key, value: decrypted });
        
        return decrypted;
    }

    set(key, value, options = {}) {
        this._ensureInitialized();
        
        const path = this._normalizePath(key);
        const oldValue = this._getValueByPath(path);
        
        // اعتبارسنجی
        if (options.validate !== false) {
            const isValid = this._validateValue(key, value, options.source);
            if (!isValid) {
                throw new Error(`Validation failed for key: ${key}`);
            }
        }

        // رمزنگاری اگر لازم باشد
        const finalValue = this._shouldEncrypt(key) ? 
            this._encryptValue(key, value) : value;

        // ذخیره سازی
        this._setValueByPath(path, finalValue);
        
        // انتشار رویداد
        this._eventBus.emit('config:set', {
            key,
            oldValue,
            newValue: value,
            source: options.source || 'manual',
            timestamp: Date.now(),
            encrypted: this._shouldEncrypt(key)
        });

        // اطلاع به واتچرها
        this._notifyWatchers(key, value, oldValue);

        return this;
    }

    watch(key, callback, options = {}) {
        const watchId = Symbol(`watch_${Date.now()}`);
        const normalizedKey = this._normalizePath(key);
        
        if (!this._state.watchers.has(normalizedKey)) {
            this._state.watchers.set(normalizedKey, new Map());
        }
        
        this._state.watchers.get(normalizedKey).set(watchId, {
            callback,
            options: {
                immediate: options.immediate || false,
                deep: options.deep || false,
                once: options.once || false,
                ...options
            }
        });

        // اجرای فوری اگر درخواست شده
        if (options.immediate) {
            try {
                callback(this.get(key), undefined, key);
            } catch (error) {
                console.error('[Config] Watcher immediate callback error:', error);
            }
        }

        // تابع لغو اشتراک
        return () => {
            const keyWatchers = this._state.watchers.get(normalizedKey);
            if (keyWatchers) {
                keyWatchers.delete(watchId);
                if (keyWatchers.size === 0) {
                    this._state.watchers.delete(normalizedKey);
                }
            }
        };
    }

    validate(key, value = null) {
        const testValue = value !== null ? value : this.get(key);
        const schema = this._config.validation.schemas[key];
        
        if (!schema) {
            return { valid: true, warnings: ['No schema defined for validation'] };
        }

        const result = this._validateWithSchema(key, testValue, schema);
        
        this._eventBus.emit('config:validate', {
            key,
            value: testValue,
            valid: result.valid,
            errors: result.errors
        });

        return result;
    }

    async reload(source = null) {
        this._state.loading = true;
        this._eventBus.emit('config:reload:start', { source });
        
        try {
            if (source) {
                await this._loadSource(source);
            } else {
                await this._loadAllSources();
            }
            
            await this._validateAll();
            await this._mergeConfigurations();
            
            this._state.lastLoad = Date.now();
            
            this._eventBus.emit('config:reload:success', {
                source,
                timestamp: this._state.lastLoad
            });
            
        } catch (error) {
            this._eventBus.emit('config:reload:error', {
                source,
                error: error.message
            });
            throw error;
        } finally {
            this._state.loading = false;
        }
        
        return this;
    }

    export(options = {}) {
        const data = this._getAllDecrypted();
        const format = options.format || 'json';
        
        let result;
        switch (format) {
            case 'json':
                result = JSON.stringify(data, null, options.pretty ? 2 : 0);
                break;
            case 'yaml':
                result = this._convertToYaml(data);
                break;
            case 'env':
                result = this._convertToEnv(data);
                break;
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
        
        this._eventBus.emit('config:export', {
            format,
            size: result.length,
            encrypted: options.encrypt || false
        });
        
        return result;
    }

    // ==================== متدهای کمکی ====================
    _initializeAdapters() {
        // آداپتور فایل
        this._adapters.set('file', {
            load: async (filePath) => {
                try {
                    const response = await fetch(filePath);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.warn(`[Config] Failed to load file: ${filePath}`, error);
                    return null;
                }
            },
            priority: 20
        });

        // آداپتور محیط
        this._adapters.set('env', {
            load: async () => {
                const envVars = {};
                const prefix = this._config.sources.environment;
                
                if (typeof process !== 'undefined' && process.env) {
                    // Node.js environment
                    Object.keys(process.env)
                        .filter(key => key.startsWith(prefix))
                        .forEach(key => {
                            const configKey = key.slice(prefix.length).toLowerCase();
                            envVars[configKey] = process.env[key];
                        });
                } else if (typeof window !== 'undefined') {
                    // Browser environment
                    const storageKey = `${prefix}CONFIG`;
                    const stored = localStorage.getItem(storageKey);
                    if (stored) {
                        try {
                            Object.assign(envVars, JSON.parse(stored));
                        } catch (e) {
                            console.warn('[Config] Failed to parse env from localStorage');
                        }
                    }
                }
                
                return envVars;
            },
            priority: 10
        });

        // آداپتور پیش‌فرض
        this._adapters.set('default', {
            load: async () => this._config.sources.defaults,
            priority: 0
        });

        // آداپتور ریموت (اگر تنظیم شده باشد)
        if (this._config.sources.remote) {
            this._adapters.set('remote', {
                load: async () => {
                    try {
                        const response = await fetch(this._config.sources.remote);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        return await response.json();
                    } catch (error) {
                        console.warn('[Config] Failed to load remote config:', error);
                        return null;
                    }
                },
                priority: 30
            });
        }
    }

    async _loadAllSources() {
        const sources = Array.from(this._adapters.entries())
            .sort((a, b) => b[1].priority - a[1].priority);
        
        const loadPromises = sources.map(async ([name, adapter]) => {
            try {
                const data = await adapter.load();
                if (data) {
                    this._sourceCache.set(name, {
                        data,
                        timestamp: Date.now(),
                        valid: true
                    });
                    this._eventBus.emit('config:source:loaded', { name, count: Object.keys(data).length });
                }
                return { name, success: !!data };
            } catch (error) {
                this._eventBus.emit('config:source:error', { name, error: error.message });
                return { name, success: false, error: error.message };
            }
        });
        
        const results = await Promise.allSettled(loadPromises);
        
        // گزارش نتایج
        const successful = results.filter(r => r.status === 'fulfilled' && r.value.success);
        const failed = results.filter(r => r.status === 'rejected' || !r.value.success);
        
        this._eventBus.emit('config:load:complete', {
            successful: successful.length,
            failed: failed.length,
            sources: sources.map(([name]) => name)
        });
    }

    async _loadSource(sourceName) {
        const adapter = this._adapters.get(sourceName);
        if (!adapter) {
            throw new Error(`Unknown config source: ${sourceName}`);
        }
        
        const data = await adapter.load();
        if (data) {
            this._sourceCache.set(sourceName, {
                data,
                timestamp: Date.now(),
                valid: true
            });
        }
        
        return data;
    }

    async _validateAll() {
        const errors = [];
        
        for (const [key, schema] of Object.entries(this._config.validation.schemas)) {
            const value = this._getValueByPath(this._normalizePath(key));
            if (value !== undefined) {
                const result = this._validateWithSchema(key, value, schema);
                if (!result.valid) {
                    errors.push({ key, errors: result.errors });
                }
            }
        }
        
        this._state.validationErrors = errors;
        
        if (errors.length > 0 && this._config.validation.strict) {
            throw new Error(`Configuration validation failed: ${JSON.stringify(errors)}`);
        }
        
        this._eventBus.emit('config:validate:complete', {
            total: Object.keys(this._config.validation.schemas).length,
            errors: errors.length,
            details: errors
        });
    }

    async _mergeConfigurations() {
        // پاک‌سازی داده‌های قبلی
        this._data.clear();
        this._encryptedData.clear();
        
        // ادغام بر اساس اولویت
        const sources = Array.from(this._sourceCache.entries())
            .sort((a, b) => {
                const adapterA = this._adapters.get(a[0]);
                const adapterB = this._adapters.get(b[0]);
                return (adapterB?.priority || 0) - (adapterA?.priority || 0);
            });
        
        for (const [sourceName, cache] of sources) {
            if (cache.valid && cache.data) {
                this._deepMerge(this._data, cache.data);
                this._eventBus.emit('config:merge:source', {
                    source: sourceName,
                    keys: Object.keys(cache.data)
                });
            }
        }
        
        // اعمال رمزنگاری
        this._applyEncryption();
        
        this._eventBus.emit('config:merge:complete', {
            totalKeys: this._data.size + this._encryptedData.size,
            encryptedKeys: this._encryptedData.size
        });
    }

    _validateValue(key, value, source = 'unknown') {
        const schema = this._config.validation.schemas[key];
        if (!schema) return true;
        
        const cacheKey = `${key}_${JSON.stringify(value)}`;
        if (this._validationCache.has(cacheKey)) {
            return this._validationCache.get(cacheKey);
        }
        
        const result = this._validateWithSchema(key, value, schema);
        this._validationCache.set(cacheKey, result.valid);
        
        if (!result.valid) {
            this._eventBus.emit('config:validate:fail', {
                key,
                value,
                source,
                errors: result.errors
            });
        }
        
        return result.valid;
    }

    _validateWithSchema(key, value, schema) {
        const errors = [];
        
        // بررسی نوع
        if (schema.type && typeof value !== schema.type) {
            errors.push(`Expected type ${schema.type}, got ${typeof value}`);
        }
        
        // بررسی الزامی بودن
        if (schema.required && (value === undefined || value === null)) {
            errors.push('Value is required');
        }
        
        // بررسی مقادیر مجاز
        if (schema.enum && !schema.enum.includes(value)) {
            errors.push(`Value must be one of: ${schema.enum.join(', ')}`);
        }
        
        // بررسی محدوده عددی
        if (schema.type === 'number') {
            if (schema.min !== undefined && value < schema.min) {
                errors.push(`Value must be >= ${schema.min}`);
            }
            if (schema.max !== undefined && value > schema.max) {
                errors.push(`Value must be <= ${schema.max}`);
            }
        }
        
        // بررسی طول رشته
        if (schema.type === 'string') {
            if (schema.minLength !== undefined && value.length < schema.minLength) {
                errors.push(`Length must be >= ${schema.minLength}`);
            }
            if (schema.maxLength !== undefined && value.length > schema.maxLength) {
                errors.push(`Length must be <= ${schema.maxLength}`);
            }
            if (schema.pattern && !new RegExp(schema.pattern).test(value)) {
                errors.push(`Must match pattern: ${schema.pattern}`);
            }
        }
        
        // اعتبارسنجی سفارشی
        if (schema.validate && typeof schema.validate === 'function') {
            try {
                const customResult = schema.validate(value);
                if (customResult !== true) {
                    errors.push(customResult || 'Custom validation failed');
                }
            } catch (error) {
                errors.push(`Custom validator error: ${error.message}`);
            }
        }
        
        return {
            valid: errors.length === 0,
            errors: errors.length > 0 ? errors : null
        };
    }

    _normalizePath(path) {
        if (Array.isArray(path)) return path;
        return path.split('.').filter(Boolean);
    }

    _getValueByPath(path) {
        let current = this._data;
        
        for (const segment of path) {
            if (current && typeof current === 'object' && current.has(segment)) {
                current = current.get(segment);
            } else if (current && typeof current === 'object' && segment in current) {
                current = current[segment];
            } else {
                return undefined;
            }
        }
        
        return current;
    }

    _setValueByPath(path, value) {
        let current = this._data;
        
        for (let i = 0; i < path.length - 1; i++) {
            const segment = path[i];
            if (!current.has(segment)) {
                current.set(segment, new Map());
            }
            current = current.get(segment);
        }
        
        const lastSegment = path[path.length - 1];
        current.set(lastSegment, value);
    }

    _deepMerge(target, source) {
        for (const [key, value] of Object.entries(source)) {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                if (!target.has(key)) {
                    target.set(key, new Map());
                }
                this._deepMerge(target.get(key), value);
            } else {
                target.set(key, value);
            }
        }
    }

    _shouldEncrypt(key) {
        if (!this._config.security.encryptSensitive) return false;
        if (!this._config.security.encryptionKey) return false;
        
        return this._config.security.maskKeys.some(mask => 
            key.toLowerCase().includes(mask.toLowerCase())
        );
    }

    _encryptValue(key, value) {
        if (!this._config.security.encryptionKey) return value;
        
        try {
            const encrypted = this._simpleEncrypt(value, this._config.security.encryptionKey);
            this._encryptedData.set(key, encrypted);
            return '[ENCRYPTED]';
        } catch (error) {
            console.warn('[Config] Encryption failed:', error);
            return value;
        }
    }

    _decryptIfNeeded(key, value) {
        if (value === '[ENCRYPTED]' && this._encryptedData.has(key)) {
            try {
                return this._simpleDecrypt(
                    this._encryptedData.get(key),
                    this._config.security.encryptionKey
                );
            } catch (error) {
                console.warn('[Config] Decryption failed:', error);
                return value;
            }
        }
        return value;
    }

    _simpleEncrypt(value, key) {
        const json = JSON.stringify(value);
        let result = '';
        for (let i = 0; i < json.length; i++) {
            result += String.fromCharCode(json.charCodeAt(i) ^ key.charCodeAt(i % key.length));
        }
        return btoa(result);
    }

    _simpleDecrypt(encrypted, key) {
        try {
            const decoded = atob(encrypted);
            let result = '';
            for (let i = 0; i < decoded.length; i++) {
                result += String.fromCharCode(decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length));
            }
            return JSON.parse(result);
        } catch (error) {
            throw new Error('Decryption failed: ' + error.message);
        }
    }

    _applyEncryption() {
        for (const [key, value] of this._data) {
            if (this._shouldEncrypt(key)) {
                const encrypted = this._encryptValue(key, value);
                this._data.set(key, '[ENCRYPTED]');
                this._encryptedData.set(key, encrypted);
            }
        }
    }

    _getAllDecrypted() {
        const result = {};
        
        for (const [key, value] of this._data) {
            result[key] = this._decryptIfNeeded(key, value);
        }
        
        return result;
    }

    _notifyWatchers(key, newValue, oldValue) {
        const normalizedKey = this._normalizePath(key).join('.');
        const watchers = this._state.watchers.get(normalizedKey);
        
        if (watchers) {
            for (const [watchId, config] of watchers) {
                try {
                    config.callback(newValue, oldValue, key);
                    
                    if (config.options.once) {
                        watchers.delete(watchId);
                    }
                } catch (error) {
                    console.error('[Config] Watcher callback error:', error);
                }
            }
            
            if (watchers.size === 0) {
                this._state.watchers.delete(normalizedKey);
            }
        }
    }

    _ensureInitialized() {
        if (!this._state.initialized) {
            throw new Error('Config manager not initialized. Call init() first.');
        }
    }

    _convertToYaml(data) {
        const convert = (obj, indent = '') => {
            let result = '';
            for (const [key, value] of Object.entries(obj)) {
                result += indent + key + ': ';
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    result += '\n' + convert(value, indent + '  ');
                } else if (Array.isArray(value)) {
                    result += '\n' + value.map(item => indent + '  - ' + JSON.stringify(item)).join('\n');
                } else {
                    result += JSON.stringify(value);
                }
                result += '\n';
            }
            return result;
        };
        return convert(data);
    }

    _convertToEnv(data) {
        const prefix = this._config.sources.environment;
        let result = '';
        
        const flatten = (obj, parentKey = '') => {
            for (const [key, value] of Object.entries(obj)) {
                const envKey = (parentKey ? parentKey + '_' : '') + key.toUpperCase();
                
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    flatten(value, envKey);
                } else {
                    result += `${prefix}${envKey}=${JSON.stringify(value)}\n`;
                }
            }
        };
        
        flatten(data);
        return result;
    }

    // ==================== متدهای دسترسی ====================
    isInitialized() { return this._state.initialized; }
    isLoading() { return this._state.loading; }
    getLastLoadTime() { return this._state.lastLoad; }
    getValidationErrors() { return [...this._state.validationErrors]; }
    getSources() { return Array.from(this._sourceCache.keys()); }
    hasKey(key) { return this._getValueByPath(this._normalizePath(key)) !== undefined; }
}

// ==================== فکتوری برای ایجاد آسان ====================
class ConfigFactory {
    static create(eventBus, options = {}) {
        return new VakamovaConfig(eventBus, options);
    }
    
    static async createAndInit(eventBus, options = {}) {
        const config = new VakamovaConfig(eventBus, options);
        await config.init();
        return config;
    }
}

// ==================== اکسپورت ====================
export { VakamovaConfig, ConfigFactory };
export default VakamovaConfig;
